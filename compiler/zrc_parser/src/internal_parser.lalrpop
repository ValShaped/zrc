// DO NOT IMPORT DIRECTLY -- USE API EXPOSED BY MODULE parser INSTEAD
use super::ast::{expr::{Expr,Arithmetic,Assignment,BinaryBitwise,Logic}, stmt::{Stmt, ArgumentDeclaration, LetDeclaration, Declaration}, ty::Type};
use super::lexer;
use lalrpop_util::ErrorRecovery;

grammar<'err>(errors: &'err mut Vec<ErrorRecovery<usize, lexer::Tok, lexer::LexicalError>>);

CommaSeparated<T>: Vec<T> = {
    <e:T> <mut v:("," <T>)*> ","? => {
        let mut new = vec![e];
        new.append(&mut v);
        new
    }
};

CommaSeparatedWithoutTrailing<T>: Vec<T> = {
    <e:T> <mut v:("," <T>)*> => {
        let mut new = vec![e];
        new.append(&mut v);
        new
    }
}

pub Program: Vec<Declaration> = DeclarationList;

DeclarationList: Vec<Declaration> = Declaration*;

// See https://en.wikipedia.org/wiki/Dangling_else#Avoiding_the_conflict_in_LR_parsers for why this
// is necessary. The ClosedStmt rule REQUIRES that an 'else' clause is used, meaning that it will
// attach to the inner 'if' statement.
pub Stmt: Stmt = {
    <OpenStmt>,
    <ClosedStmt>
}

OpenStmt: Stmt = {
    "if" "(" <e:Expr> ")" <s:Stmt> => Stmt::IfStmt(e, Box::new(s), None),
    "if" "(" <a:Expr> ")" <b:ClosedStmt> "else" <c:OpenStmt> => 
        Stmt::IfStmt(a, Box::new(b), Some(Box::new(c))),
    "while" "(" <a:Expr> ")" <b:OpenStmt> => Stmt::WhileStmt(a, Box::new(b)),
    "for" "(" <a:Declaration> <b:Expr?> ";" <c:Expr?> ")" <d:OpenStmt> => Stmt::ForStmt {
        init: Some(Box::new(a)),
        cond: b,
        post: c,
        body: Box::new(d)
    },
    "for" "(" ";" <b:Expr?> ";" <c:Expr?> ")" <d:OpenStmt> => Stmt::ForStmt {
        init: None,
        cond: b,
        post: c,
        body: Box::new(d)
    },
};

ClosedStmt: Stmt = {
    <SimpleStmt>,
    "if" "(" <a:Expr> ")" <b:ClosedStmt> "else" <c:ClosedStmt> =>
        Stmt::IfStmt(a, Box::new(b), Some(Box::new(c))),
    "while" "(" <a:Expr> ")" <b:ClosedStmt> => Stmt::WhileStmt(a, Box::new(b)),
    "for" "(" <a:Declaration> <b:Expr?> ";" <c:Expr?> ")" <d:ClosedStmt> => Stmt::ForStmt {
        init: Some(Box::new(a)),
        cond: b,
        post: c,
        body: Box::new(d)
    },
    "for" "(" ";" <b:Expr?> ";" <c:Expr?> ")" <d:ClosedStmt> => Stmt::ForStmt {
        init: None,
        cond: b,
        post: c,
        body: Box::new(d)
    },
};

SimpleStmt: Stmt = {
    <Expr> ";" => Stmt::ExprStmt(<>),
    ";" => Stmt::EmptyStmt,
    "{" <l:StmtList?> "}" => Stmt::BlockStmt(l.unwrap_or(Vec::new())),
    <FlowStmt>,
    <Declaration> => Stmt::Declaration(<>),
};

Declaration: Declaration = {
    <LetDeclaration>,
    // FIXME: This might allow code like for (fn foo() {};;) {} to work. Do we want this?
    <FunctionDeclaration>,
};

FunctionDeclaration: Declaration = {
    "fn" <i:IDENTIFIER> "(" <a:ArgumentDeclarationList?> ")" <r:("->" <Type>)?> "{"
        <s:StmtList?>
    "}" => Declaration::FunctionDefinition {
        name: i,
        parameters: a.unwrap_or(Vec::new()),
        return_type: r,
        body: s.unwrap_or(Vec::new())
    }
    // TODO: External declarations
};

ArgumentDeclarationList = CommaSeparated<ArgumentDeclaration>;

ArgumentDeclaration: ArgumentDeclaration = {
    <i:IDENTIFIER> <t:(":" <Type>)?> => ArgumentDeclaration {
        name: i,
        ty: t
    }
};

LetDeclaration: Declaration = {
    "let" <l:CommaSeparatedWithoutTrailing<
        (<IDENTIFIER> <(":" <Type>)?> <("=" <Assignment>)?>)
    >> ";" => Declaration::DeclarationList(l.into_iter().map(|(i, t, v)| LetDeclaration {
        name: (i),
        ty: t,
        value: v,
    }).collect::<Vec<_>>()),
};

Type: Type = {
    <IDENTIFIER> => Type::Identifier(<>),
}

FlowStmt: Stmt = {
    "continue" ";" => Stmt::ContinueStmt,
    "break" ";" => Stmt::BreakStmt,
    "return" <e:Expr?> ";" => Stmt::ReturnStmt(e),
};

StmtList: Vec<Stmt> = Stmt+;

pub Expr: Expr = Comma;

Comma: Expr = {
    <l:Comma> "," <r:Assignment> => Expr::Comma(Box::new(l), Box::new(r)),
    <Assignment>
}

Assignment: Expr = {
    <lhs:Unary> "=" <rhs:Assignment> => Expr::Assignment(Assignment::Standard, Box::new(lhs), Box::new(rhs)),
    <lhs:Unary> "+=" <rhs:Assignment> => Expr::Assignment(Assignment::Arithmetic(Arithmetic::Addition), Box::new(lhs), Box::new(rhs)),
    <lhs:Unary> "-=" <rhs:Assignment> => Expr::Assignment(Assignment::Arithmetic(Arithmetic::Subtraction), Box::new(lhs), Box::new(rhs)),
    <lhs:Unary> "*=" <rhs:Assignment> => Expr::Assignment(Assignment::Arithmetic(Arithmetic::Multiplication), Box::new(lhs), Box::new(rhs)),
    <lhs:Unary> "/=" <rhs:Assignment> => Expr::Assignment(Assignment::Arithmetic(Arithmetic::Division), Box::new(lhs), Box::new(rhs)),
    <lhs:Unary> "%=" <rhs:Assignment> => Expr::Assignment(Assignment::Arithmetic(Arithmetic::Modulo), Box::new(lhs), Box::new(rhs)),
    <lhs:Unary> "&=" <rhs:Assignment> => Expr::Assignment(Assignment::BinaryBitwise(BinaryBitwise::And), Box::new(lhs), Box::new(rhs)),
    <lhs:Unary> "|=" <rhs:Assignment> => Expr::Assignment(Assignment::BinaryBitwise(BinaryBitwise::Or), Box::new(lhs), Box::new(rhs)),
    <lhs:Unary> "^=" <rhs:Assignment> => Expr::Assignment(Assignment::BinaryBitwise(BinaryBitwise::Xor), Box::new(lhs), Box::new(rhs)),
    <lhs:Unary> "<<=" <rhs:Assignment> => Expr::Assignment(Assignment::BinaryBitwise(BinaryBitwise::Shl), Box::new(lhs), Box::new(rhs)),
    <lhs:Unary> ">>=" <rhs:Assignment> => Expr::Assignment(Assignment::BinaryBitwise(BinaryBitwise::Shr), Box::new(lhs), Box::new(rhs)),
}

Ternary: Expr = {
    <l:Logical> "?" <c:Expr> ":" <r:Ternary> => Expr::Ternary(Box::new(l), Box::new(c), Box::new(r)),
    <Logical>
};

Logical: Expr = LogicalOr;
LogicalOr: Expr = {
    <l:LogicalOr> "||" <r:LogicalAnd> => Expr::Logic(Logic::Or, Box::new(l), Box::new(r)),
    <LogicalAnd>,
};
LogicalAnd: Expr = {
    <l:LogicalAnd> "&&" <r:Equality> => Expr::Logic(Logic::And, Box::new(l), Box::new(r)),
    <Bitwise>
};

Bitwise: Expr = BitwiseOr;
BitwiseOr: Expr = {
    <l:BitwiseOr> "|" <r:BitwiseXor> => Expr::BinaryBitwise(BinaryBitwise::Or, Box::new(l), Box::new(r)),
    <BitwiseXor>
};
BitwiseXor: Expr = {
    <l:BitwiseXor> "^" <r:BitwiseAnd> => Expr::BinaryBitwise(BinaryBitwise::Xor, Box::new(l), Box::new(r)),
    <BitwiseAnd>,
};
BitwiseAnd: Expr = {
    <l:BitwiseAnd> "&" <r:Equality> => Expr::BinaryBitwise(BinaryBitwise::And, Box::new(l), Box::new(r)),
    <Equality>,
}

Equality: Expr = {
    <l:Equality> "==" <r:Comparison> => Expr::Logic(Logic::Eq, Box::new(l), Box::new(r)),
    <l:Equality> "!=" <r:Comparison> => Expr::Logic(Logic::Neq, Box::new(l), Box::new(r)),
    <Comparison>
};


Comparison: Expr = {
    <l:Comparison> ">" <r:BitShift> => Expr::Logic(Logic::Gt, Box::new(l), Box::new(r)),
    <l:Comparison> ">=" <r:BitShift> => Expr::Logic(Logic::Gte, Box::new(l), Box::new(r)),
    <l:Comparison> "<" <r:BitShift> => Expr::Logic(Logic::Lt, Box::new(l), Box::new(r)),
    <l:Comparison> "<=" <r:BitShift> => Expr::Logic(Logic::Lte, Box::new(l), Box::new(r)),
    <BitShift>
};

BitShift: Expr = {
    <l:BitShift> ">>" <r:Term> => Expr::BinaryBitwise(BinaryBitwise::Shr, Box::new(l), Box::new(r)),
    <l:BitShift> "<<" <r:Term> => Expr::BinaryBitwise(BinaryBitwise::Shl, Box::new(l), Box::new(r)),
    <Term>
};

Term: Expr = {
    <l:Term> "+" <r:Factor> => Expr::Arithmetic(Arithmetic::Addition, Box::new(l), Box::new(r)),
    <l:Term> "-" <r:Factor> => Expr::Arithmetic(Arithmetic::Subtraction, Box::new(l), Box::new(r)),
    <Factor>
};

Factor: Expr = {
    <l:Factor> "/" <r:Unary> => Expr::Arithmetic(Arithmetic::Division, Box::new(l), Box::new(r)),
    <l:Factor> "*" <r:Unary> => Expr::Arithmetic(Arithmetic::Multiplication, Box::new(l), Box::new(r)),
    <l:Factor> "%" <r:Unary> => Expr::Arithmetic(Arithmetic::Modulo, Box::new(l), Box::new(r)),
    <Unary>
};

Unary: Expr = {
    "!" <Unary> => Expr::UnaryNot(Box::new(<>)),
    "-" <Unary> => Expr::UnaryMinus(Box::new(<>)),
    "~" <Unary> => Expr::UnaryBitwiseNot(Box::new(<>)),
    "&" <Unary> => Expr::UnaryAddressOf(Box::new(<>)),
    "*" <Unary> => Expr::UnaryDereference(Box::new(<>)),
    <Postfix>
};

Postfix: Expr = {
    <x:Postfix> "[" <i:Expr> "]" => Expr::Index(Box::new(x), Box::new(i)),
    <l:Postfix> "." <r:IDENTIFIER> => Expr::Dot(Box::new(l), r),
    <l:Postfix> "->" <r:IDENTIFIER> => Expr::Arrow(Box::new(l), r),
    <i:Postfix> "(" <l:ArgumentList?> ")" => Expr::Call(Box::new(i), l.unwrap_or(Vec::new())),
    <Primary>
};

ArgumentList: Vec<Expr> = CommaSeparated<Assignment>;

Primary: Expr = {
    NUMBER => Expr::NumberLiteral(<>),
    STRING => Expr::StringLiteral(<>),
    IDENTIFIER => Expr::Identifier(<>),
    "true" => Expr::BooleanLiteral(true),
    "false" => Expr::BooleanLiteral(false),
    "(" <Expr> ")" => <>,
    ! => { errors.push(<>); Expr::Error }
};

extern {
    type Location = usize;
    type Error = lexer::LexicalError;

    enum lexer::Tok {
        "+" => lexer::Tok::Plus,
        "-" => lexer::Tok::Minus,
        "*" => lexer::Tok::Star,
        "/" => lexer::Tok::Slash,
        "%" => lexer::Tok::Percent,
        "++" => lexer::Tok::PlusPlus,
        "--" => lexer::Tok::MinusMinus,

        "==" => lexer::Tok::EqEq,
        "!=" => lexer::Tok::NotEq,
        ">" => lexer::Tok::Greater,
        ">=" => lexer::Tok::GreaterEq,
        "<" => lexer::Tok::Less,
        "<=" => lexer::Tok::LessEq,

        "&&" => lexer::Tok::LogicalAnd,
        "||" => lexer::Tok::LogicalOr,
        "!" => lexer::Tok::LogicalNot,

        "&" => lexer::Tok::BitwiseAnd,
        "|" => lexer::Tok::BitwiseOr,
        "^" => lexer::Tok::BitwiseXor,
        "~" => lexer::Tok::BitwiseNot,
        "<<" => lexer::Tok::BitwiseLeftShift,
        ">>" => lexer::Tok::BitwiseRightShift,

        "=" => lexer::Tok::Assign,
        "+=" => lexer::Tok::PlusAssign,
        "-=" => lexer::Tok::MinusAssign,
        "*=" => lexer::Tok::StarAssign,
        "/=" => lexer::Tok::SlashAssign,
        "%=" => lexer::Tok::PercentAssign,
        "&=" => lexer::Tok::BitwiseAndAssign,
        "|=" => lexer::Tok::BitwiseOrAssign,
        "^=" => lexer::Tok::BitwiseXorAssign,
        "<<=" => lexer::Tok::BitwiseLeftShiftAssign,
        ">>=" => lexer::Tok::BitwiseRightShiftAssign,

        ";" => lexer::Tok::Semicolon,
        "," => lexer::Tok::Comma,
        "." => lexer::Tok::Dot,
        "?" => lexer::Tok::QuestionMark,
        ":" => lexer::Tok::Colon,
        "::" => lexer::Tok::ColonColon,

        "(" => lexer::Tok::LeftParen,
        ")" => lexer::Tok::RightParen,
        "{" => lexer::Tok::LeftBrace,
        "}" => lexer::Tok::RightBrace,
        "[" => lexer::Tok::LeftBracket,
        "]" => lexer::Tok::RightBracket,

        STRING => lexer::Tok::StringLiteral(<String>),
        NUMBER => lexer::Tok::NumberLiteral(<String>),
        IDENTIFIER => lexer::Tok::Identifier(<String>),

        "true" => lexer::Tok::True,
        "false" => lexer::Tok::False,
        "if" => lexer::Tok::If,
        "else" => lexer::Tok::Else,
        "while" => lexer::Tok::While,
        "for" => lexer::Tok::For,
        "break" => lexer::Tok::Break,
        "continue" => lexer::Tok::Continue,
        "return" => lexer::Tok::Return,
        "let" => lexer::Tok::Let,
        "fn" => lexer::Tok::Fn,
        "->" => lexer::Tok::SmallArrow,
    }
}